##Three-State Memory
http://open.kattis.com/problems/memory  
Solution author: Finn Lidbetter, Micah Stairs, William Fiset  
Solution date: 19/01/17  

Solution:  
The first observation to make is that given a binary string, or three-state string, we can create an alternate representation by changing 10 to 02, or 20 to 12 anywhere in the string without changing the value that it represents. Next we can observe that if we perform one of these transformations on something like 1000 (a 1 followed by more than one 0) we can apply transformations iteratively, i.e. 1000 -> 0200 -> 0120 -> 0112. Notice, however, that in doing so there will always still be a 1 in the position immediately to the right of where original 1 was. Since all transformations require a 0 to the right, we know that no more transformations can be performed once we reach a position that will be occupied by a 1. From this information we can create a linear DP solution.  
We will calculate the answer by processing each 1 in the original binary string from right to left and keep track of 3 pieces of information: *(1)* the position of the last 1 that was processed, *(2)* the number of representations that could be achieved without transforming the most recent 1 encountered, *(3)* the number of representations that could be achieved by transforming the most recent 1 any number of times greater than 0. Note that for case *(3)* transforming a 1 once vs. *n* times for *n>1* doens't make a difference to the left most position of the 1 or 2 that will be created by the transformation as seen in the 1000 example above.  
For the first 1 that we encounter, there is one representation that can be achieved by not transforming it at all, and another representation for every 0 that preceeded it. For the next 1 that we encounter the number of representations that we can get by not transforming it will be the sum of the number of representations achievable by transforming and not transforming the most recent 1 encountered. The number of representations that we can get by transforming will be the sum of: the number of 0s between this 1 and the most recent 1 multiplied by *(2)*, and the number of 0s plus 1 between this 1 and the most recent 1 multiplied *(3)*. Note that the number of 0s between this 1 and the most recent 1 can be determined from (1).  
We apply this procedure to each 1 that is in the binary string and print out the answer, modding as appropriate throughout the calculation.
